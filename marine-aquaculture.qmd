---
title: "Investigating Exclusive Economic Zones (EEZ) for Marine Aquaculture"
subtitle: "EDS-223 Assignment 4"
author: "Isabella Segarra"
date: 11-10-2025
format: 
  pdf: default 
  html: default
theme: pandoc
execute: 
  warning: false
  message: false
---
# Species for Marine Aquaculture in West Coast EEZs

![README](figs/README-screenshot.png)

## Objectives:
Marine aquaculture has become popular for its use as a more suitable protein option than land-based meat production.In this project, I investigated where to prioritize marine aquaculture in the West Coast of the United States. I focused on two focal species: oysters and blue mussels. 

My workflow outline is as follows:
1. Process sea surface temperature data
2. Process depth data
3. Reclassify sea surface temperature and depth data
4. Apply mask 

- process sea surface and depth data 
- find suitable locations for 

## Environment set-up
Load relevant libraries.
```{r}
#| label: Library import
#| output: false
#| message: false

library(sf) # For vector data
library(stars) # For raster data
library(terra) # raster handling
library(tmap) # For static and interactive maps
library(here) # For importing data 
library(tidyverse) # For data cleaning
library(dplyr) # For filtering data 
library(paletteer) # For pretty colors 
library(testthat) # For efficient workflows 
library(kableExtra) # For pretty tables 
library(patchwork) # For plotting 

```

## Data Import and Preparation
The data for this study includes a shapefile for the West Coast EEZ, bathymetry (depth) raster, and sea surface temperature raster. 

### Species data
The two focal species for this study are oysters and blue mussels (*Mytilus edulis*). Both of these bivalve species are found in the Pacific ocean and have the ability to serve as a great protein source for marine aquaculture. 

![Oyster photo]()
![Blue mussel]()

```{r}
#| echo: false 

species <- c("Oysters", "Blue Mussel")
temperatures <- c("11-30°C", "5-20°C")
depths <- c("0-70 m", "0-60 m")

# Combine into a table
species_table <- data.frame(
  species,
  temperatures,
  depths
)

# Put together with ‘kableExtra’
species_table %>%
  kable(col.names = c("Species", "Temperature Range", "Depth Range"), caption = "Table 1. Species information") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

```

### Sea Surface Temperature Data
In this study, I will use average annual sea surface temperature (SST) from 2008 to 2012. The data is from NOAA's Daily Global Satellite Sea Surface Temperature anomaly. 
It contains the following data: 
```{r}
#| output: false 
#| message: false

#......Import Sea Surface Temperature Data......

# Read in SST rasters in a raster stack 
sst_fp <- list.files(here("data"), pattern = "average_annual_sst_", full.names = TRUE)
# Stack 
sst <- rast(sst_fp) %>% 
  project("EPSG:4326") # project CRS 

```

In this section, I will process the sea surface temperature (SST) data in order to combine it with the depth data. The SST data needs to be averaged and converted into celcius. 
```{r}
#......Data Wrangling......

# Find the average sea surface temperature from 2008-2012
avg_sst <- mean(sst)

# Convert average SST from Kelvin to Celsius
avg_sst_c <- avg_sst - 273.15

# Clear working environment
rm(list = 'avg_sst')

```

### Depth Data
In this study, I will use bathymetry data from the General Bathymetric Chart of the Oceans. 
```{r}
#| output: false 
#| message: false

#......Import Depth Data......
depth <- rast(here("data/depth.tif")) %>% 
  project("EPSG:4326") # project CRS

```

In this section, I matched the resolution (number and size of pixels) of depth to match `avg_sst_c`.

```{r}
#......Crop depth raster......

# Create extent of 'avg_sst_c'
ext_sst <- ext(avg_sst_c)

# Crop depth raster to match the extent of the SST raster
depth_cropped <- crop(depth, ext_sst)

# Ensure data was cropped 
if(ncell(depth) == ncell(depth_cropped)) {
  warning("data did not crop!")
} else {
  message("data cropped!")
}

```

```{r}
#......Resample......

# Resample to match resolutions 
depth <- resample(depth_cropped, avg_sst_c, method = "bilinear") # method bilinear 

# Check that the resolutions match
if (all(res(depth) == res(avg_sst_c))) {
  message("Resolutions match!")
} else {
  warning("Resolutions do not match")
}

# Remove 'depth_cropped' from environment
rm(list = 'depth_cropped')

```

```{r}
#......CRS check......

# Check that CRSs match 
if (crs(depth) != crs(avg_sst_c)) {
  warning("Coordinate refrence systems DO NOT match!")
} else {
  message("Coordinate refrence systems match!")
} 
```
## Find suitable locations
In this section I will find suitable locations (area in km) that satisfy the specific sea surface temperature and depth range for oysters. 

### Reclassificaiton Matrix 
In order to find suitable locations for the oyster, I need to reclassify `avvg_sst_c` and `depth` data into locations that are suitable for oysters. This process returns the cells in the raster that satisfy the criteria. 
- 1: suitable locations
- 0: unsuitable locations

```{r}
#......Reclassification matrix: sea surface temperature......

sst_matrix <- matrix(c(-Inf, 11, 0, # values -Inf to 11 = 0
                11, 30, 1,  # values 11 to 30 = 1
                30, Inf, 0), # values 30 to Inf = 0
              ncol = 3, byrow = TRUE)

# Apply the matrix to reclassify the raster, making all cells 0 or 1
sst_rcl <- terra::classify(avg_sst_c, rcl = sst_matrix)


# Assign Nan values as NA
values(sst_rcl)[is.nan(values(sst_rcl))] <- NA

# Check output of sst_rcl
kable(unique(values(sst_rcl)))

# Check sst values after reclassification
sum(values(sst_rcl), na.rm = TRUE)

# Ensure SST was reclassified
if (identical(values(avg_sst_c), values(sst_rcl))) {
  warning("SST not reclassified!")
} else {
  message("SST reclassified!")
}

```

```{r}
#......Reclassification matrix: Depth......

depth_matrix <- matrix(c(-Inf, -70, 0, # values -Inf to 70 = 0
                -70, 0, 1,  # values 70 to 0 = 1
                0, Inf, 0), # values 
              ncol = 3, byrow = TRUE)


# Apply the matrix to reclassify the raster, making all cells 0 or 1
depth_rcl <- terra::classify(depth, rcl = depth_matrix)

# Check output of dept_rcl
kable(unique(values(depth_rcl)))

# Check out values of depth_rcl
sum(values(depth_rcl), na.rm = TRUE)

# Ensure depth was reclassified
if (identical(values(depth), values(depth_rcl))) {
  warning("Depth not reclassified!")
} else {
  message("Depth reclassified!")
}
```
I now have suitable locations for the specific sea surface temperature and depth specifications for oysters.  
```{r}
#......Apply ......

# Multiply reclassification matrices to find suitable locations 
suitable_locations <- sst_rcl * depth_rcl 


# Convert all zeros to NA values
suitable_locations[suitable_locations == 0] <- NA

# View the cells left 
sum(values(suitable_locations), na.rm = TRUE)


# Find the area of suitable locations for oysters 
suitable_area <- expanse(suitable_locations, unit = "km")

print(paste("The total suitable area for oysters is", round(suitable_area$area, 2), "km"))


```

## Determine the most suitable EEZ
Exclusive Economic Zones are regions of the ocean that are open for a country to explore. The U.S. West coast has five regions. In this section, I will determine the total suitable area within each EEZ for oysters. This data is from [Marineregions.org](https://www.marineregions.org/eez.php).

```{r}
#| output: false 

#......Import Data and Check CRS......

# Import data
eez <- st_read(here("data", "wc_regions_clean.shp")) 

# Check if CRS match 
if (st_crs(eez) == st_crs(4326)) {
  message("CRS match with depth and average sea surface temperature")
} else {
  warning("CRS does not match! Transforming required.")
}

```
### Find suitable areas within West Coast EEZs
In this section I will find the suitable areas within West Coast EEZs
```{r}
#......Apply mask ......

# Mask suitable locations to eez habitat  
eez_cells <- mask(suitable_locations, eez) 

if (ncell(suitable_locations) == ncell(eez_cells)) {
  message("Mask worked!") 
}else {
  warning("Mask did not work")
}

```

```{r}
#......Calculate total area ......

# Calculate cell size area of each raster cell
eez_cells_area <- cellSize(eez_cells)

#......Find total area......

# Extract raster values per polygon, sum within each polygon
# Result is a data frame 
area_by_eez <- terra::extract(eez_cells_area, eez, fun = sum, na.rm = TRUE)

```

```{r}
#......Join data......

# Add polygon IDs to eez 
eez <- eez %>%
  rename(ID = rgn_id)

# Join the raster summaries back to eez polygons df 
eez_area <- eez %>%
  left_join(area_by_eez, by = "ID")
```

```{r}
#| echo: false 

rgns <- c("Oregon", "Northern California", "Central California", "Southern California", "Washington")

rgn_1_area <- eez_area$area_km2[1]
rgn_2_area <- eez_area$area_km2[2]
rgn_3_area <- eez_area$area_km2[3]
rgn_4_area <- eez_area$area_km2[4]
rgn_5_area <- eez_area$area_km2[5]

rgn_areas <- c(rgn_1_area, rgn_2_area, rgn_3_area, rgn_4_area, rgn_5_area)

rgn_table <- data.frame(
  rgns,
  rgn_areas
)

# Put together with ‘kableExtra’
rgn_table %>%
  kable(col.names = c("Regions", "Suitable Habitat (km)"), caption = "Table 2. Suitable Area") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
```
## Map: Oyster Suitable Area 
```{r}

tm_tiles("Esri.WorldImagery") +
tm_shape(eez_area) +
  tm_polygons(fill = "area_km2" , # fill polygons based on suitable area 
              style = "cont", # continuous value scale 
    palette = c("#9ef7f0", "#1d524d"), # palette of colors 
    title = "Suitable habitat (km²)") + # legend title 
  tm_layout(legend.outside = TRUE, legend.text.size = 0.8) + # legend position and size 
  tm_title("Suitable Habitat Range for Oyster Marine Aquaculture", fontface = "bold", size = 1.5) +
  tm_graticules(lwd = 0.2) +
  tm_scalebar(position = c("left", "bottom"), text.size = 0.5) +
  tm_text("rgn", size = 0.4)
                

```

## Generalizable function

```{r}
suitability_fun <- function(sst_min, sst_max, depth_min, depth_max, species) {

  # Define SST reclassification matrix 
  sst_matrix <- matrix(
    c(
      -Inf,  sst_min, 0,   # below min sst = 0/unsuitable
       sst_min, sst_max, 1, # range of sst = 1/suitable
       sst_max, Inf,    0   # above max sst = 0/unsuitable
    ),
    ncol = 3, byrow = TRUE
  )

  # Define Depth reclassification matrix 
  depth_matrix <- matrix(
    c(-Inf, depth_min, 0,  # below min depth = 0/unsuitable
       depth_min, depth_max, 1,  # range of depth = 1/suitable
       depth_max, Inf, 0         #  range of depth = 1/suitable
      ),
    ncol = 3, byrow = TRUE
  )

  # Reclassify SST 
  sst_rcl <- terra::classify(avg_sst_c, rcl = sst_matrix)
  
  # Fill NAN values with NAs 
  values(sst_rcl)[is.nan(values(sst_rcl))] <- NA

  # Reclassify depth 
  depth_rcl <- terra::classify(depth, rcl = depth_matrix)

  # Find suitable locations
  suitable_locations <- sst_rcl * depth_rcl

  # Convert zeros to NAs
  suitable_locations[suitable_locations == 0] <- NA

  # Apply mask to keep onlu suitable raster cells in eez 
  eez_cells <- mask(suitable_locations, eez)

  # Find cell area
  eez_cells_area <- cellSize(eez_cells)

  # Summarize area within eez 
  area_by_eez <- terra::extract(eez_cells_area, eez, fun = sum, na.rm = TRUE)

  # Add ID 
  #eez <- eez %>% rename(ID = rgn_id)

  # Join area back into polygons
  eez_area <- eez %>%
    left_join(area_by_eez, by = "ID")

  # Create map 
  species_map <- tm_shape(eez_area) +
    tm_polygons(fill = "area_km2") +
    tm_layout(title = paste("Suitable Habitat for", species))

  return(species_map)
}

```

## Apply function: Blue Mussels 

```{r}

# 5- 20
# 0-60 

suitability_fun(
  sst_min = 5,
  sst_max = 20,
  depth_min = 0,
  depth_max = 60,
  species = "Blue Mussel"
)


```

